<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Fluid GPU (WebGL2) - Mouse Driven</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    canvas { width:100vw; height:100vh; display:block; }
    .hud{
      position:fixed; left:12px; top:12px; color:#cfcfcf;
      font: 13px/1.25 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: rgba(0,0,0,.35); padding:10px 12px; border-radius:12px;
      backdrop-filter: blur(8px);
      user-select:none;
      max-width: 360px;
    }
    .hud b{ color:#fff; }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div class="hud">
  <b>Fluid GPU</b> (WebGL2)<br/>
  Arrastra para <b>empujar</b> + <b>pintar</b>.<br/>
  <span id="info">Inicializando…</span>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const info = document.getElementById('info');

  const gl = canvas.getContext('webgl2', { alpha:false, antialias:false, depth:false, stencil:false });
  if (!gl) { info.textContent = "❌ WebGL2 no disponible (prueba Chrome/Firefox actualizado)."; return; }

  const ext = gl.getExtension('EXT_color_buffer_float');
  if (!ext) { info.textContent = "❌ Falta EXT_color_buffer_float (tu GPU/driver lo bloquea)."; return; }

  info.textContent = "✅ OK (WebGL2 + float FBO)";

  gl.disable(gl.DEPTH_TEST);
  gl.disable(gl.STENCIL_TEST);

  function resize() {
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    const w = Math.floor(innerWidth * dpr);
    const h = Math.floor(innerHeight * dpr);
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w; canvas.height = h;
    }
    gl.viewport(0,0,canvas.width,canvas.height);
  }
  window.addEventListener('resize', resize);
  resize();

  function compile(type, src) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
      const log = gl.getShaderInfoLog(s);
      console.error(src);
      throw new Error(log);
    }
    return s;
  }
  function program(vsSrc, fsSrc) {
    const p = gl.createProgram();
    gl.attachShader(p, compile(gl.VERTEX_SHADER, vsSrc));
    gl.attachShader(p, compile(gl.FRAGMENT_SHADER, fsSrc));
    gl.bindAttribLocation(p, 0, 'aPos');
    gl.linkProgram(p);
    if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
      throw new Error(gl.getProgramInfoLog(p));
    }
    return p;
  }

  // Fullscreen quad
  const vao = gl.createVertexArray();
  gl.bindVertexArray(vao);
  const vbo = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,  1,-1,  -1,1,  1,1]), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(0);
  gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
  gl.bindVertexArray(null);

  function tex(w,h, internalFormat, format, type, filter=gl.LINEAR) {
    const t = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, t);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);
    gl.bindTexture(gl.TEXTURE_2D, null);
    return t;
  }
  function fbo(texture) {
    const fb = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    const ok = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    if (!ok) throw new Error("FBO incomplete");
    return fb;
  }
  function DoubleFBO(w,h, internalFormat, format, type, filter) {
    const t0 = tex(w,h, internalFormat, format, type, filter);
    const t1 = tex(w,h, internalFormat, format, type, filter);
    const f0 = fbo(t0);
    const f1 = fbo(t1);
    return {
      w,h,
      read: { tex:t0, fbo:f0 },
      write:{ tex:t1, fbo:f1 },
      swap(){ const tmp=this.read; this.read=this.write; this.write=tmp; }
    };
  }

  const VS = `#version 300 es
  layout(location=0) in vec2 aPos;
  out vec2 vUv;
  void main(){
    vUv = aPos*0.5 + 0.5;
    gl_Position = vec4(aPos,0.0,1.0);
  }`;

  const FS_DISPLAY = `#version 300 es
  precision highp float;
  in vec2 vUv; out vec4 o;
  uniform sampler2D uTex;
  void main(){
    vec3 c = texture(uTex, vUv).rgb;
    c = 1.0 - exp(-c * 2.2);
    o = vec4(c, 1.0);
  }`;

  const FS_ADVECT = `#version 300 es
  precision highp float;
  in vec2 vUv; out vec4 o;
  uniform sampler2D uVelocity;
  uniform sampler2D uSource;
  uniform vec2 uTexel;
  uniform float uDt;
  uniform float uDissipation;
  void main(){
    vec2 vel = texture(uVelocity, vUv).xy;
    vec2 coord = vUv - uDt * vel * uTexel;
    o = texture(uSource, coord) * uDissipation;
  }`;

  const FS_DIVERGENCE = `#version 300 es
  precision highp float;
  in vec2 vUv; out vec4 o;
  uniform sampler2D uVelocity;
  uniform vec2 uTexel;
  void main(){
    float L = texture(uVelocity, vUv - vec2(uTexel.x,0)).x;
    float R = texture(uVelocity, vUv + vec2(uTexel.x,0)).x;
    float B = texture(uVelocity, vUv - vec2(0,uTexel.y)).y;
    float T = texture(uVelocity, vUv + vec2(0,uTexel.y)).y;
    float div = 0.5*(R - L + T - B);
    o = vec4(div,0,0,1);
  }`;

  const FS_PRESSURE = `#version 300 es
  precision highp float;
  in vec2 vUv; out vec4 o;
  uniform sampler2D uPressure;
  uniform sampler2D uDivergence;
  uniform vec2 uTexel;
  void main(){
    float L = texture(uPressure, vUv - vec2(uTexel.x,0)).x;
    float R = texture(uPressure, vUv + vec2(uTexel.x,0)).x;
    float B = texture(uPressure, vUv - vec2(0,uTexel.y)).x;
    float T = texture(uPressure, vUv + vec2(0,uTexel.y)).x;
    float div = texture(uDivergence, vUv).x;
    float p = (L + R + B + T - div) * 0.25;
    o = vec4(p,0,0,1);
  }`;

  const FS_GRADIENT = `#version 300 es
  precision highp float;
  in vec2 vUv; out vec4 o;
  uniform sampler2D uPressure;
  uniform sampler2D uVelocity;
  uniform vec2 uTexel;
  void main(){
    float L = texture(uPressure, vUv - vec2(uTexel.x,0)).x;
    float R = texture(uPressure, vUv + vec2(uTexel.x,0)).x;
    float B = texture(uPressure, vUv - vec2(0,uTexel.y)).x;
    float T = texture(uPressure, vUv + vec2(0,uTexel.y)).x;
    vec2 vel = texture(uVelocity, vUv).xy;
    vel -= 0.5 * vec2(R - L, T - B);
    o = vec4(vel,0,1);
  }`;

  const FS_CURL = `#version 300 es
  precision highp float;
  in vec2 vUv; out vec4 o;
  uniform sampler2D uVelocity;
  uniform vec2 uTexel;
  void main(){
    float L = texture(uVelocity, vUv - vec2(uTexel.x,0)).y;
    float R = texture(uVelocity, vUv + vec2(uTexel.x,0)).y;
    float B = texture(uVelocity, vUv - vec2(0,uTexel.y)).x;
    float T = texture(uVelocity, vUv + vec2(0,uTexel.y)).x;
    float c = 0.5*(R - L - (T - B));
    o = vec4(c,0,0,1);
  }`;

  const FS_VORT = `#version 300 es
  precision highp float;
  in vec2 vUv; out vec4 o;
  uniform sampler2D uVelocity;
  uniform sampler2D uCurl;
  uniform vec2 uTexel;
  uniform float uDt;
  uniform float uCurlStrength;
  void main(){
    float C = texture(uCurl, vUv).x;
    float L = abs(texture(uCurl, vUv - vec2(uTexel.x,0)).x);
    float R = abs(texture(uCurl, vUv + vec2(uTexel.x,0)).x);
    float B = abs(texture(uCurl, vUv - vec2(0,uTexel.y)).x);
    float T = abs(texture(uCurl, vUv + vec2(0,uTexel.y)).x);

    vec2 grad = vec2(R - L, T - B);
    float len = length(grad) + 1e-5;
    vec2 N = grad / len;

    vec2 vel = texture(uVelocity, vUv).xy;
    vel += uDt * uCurlStrength * vec2(N.y, -N.x) * C;
    o = vec4(vel,0,1);
  }`;

  const FS_SPLAT = `#version 300 es
  precision highp float;
  in vec2 vUv; out vec4 o;
  uniform sampler2D uTarget;
  uniform vec2 uPoint;
  uniform float uRadius;
  uniform vec3 uValue;
  void main(){
    vec4 base = texture(uTarget, vUv);
    vec2 d = vUv - uPoint;
    float a = exp(-dot(d,d) / (uRadius*uRadius));
    o = vec4(base.rgb + uValue * a, 1.0);
  }`;

  const P = {
    display: program(VS, FS_DISPLAY),
    advect: program(VS, FS_ADVECT),
    divergence: program(VS, FS_DIVERGENCE),
    pressure: program(VS, FS_PRESSURE),
    gradient: program(VS, FS_GRADIENT),
    curl: program(VS, FS_CURL),
    vort: program(VS, FS_VORT),
    splat: program(VS, FS_SPLAT),
  };

  function bindTex(unit, texture) {
    gl.activeTexture(gl.TEXTURE0 + unit);
    gl.bindTexture(gl.TEXTURE_2D, texture);
  }

  // uniforms: floats/vec2/vec3 + ints explícitos con {i:...}
  function setUniform(prog, name, val) {
    const loc = gl.getUniformLocation(prog, name);
    if (loc === null) return;
    if (val && typeof val === 'object' && 'i' in val) { gl.uniform1i(loc, val.i); return; }
    if (typeof val === 'number') { gl.uniform1f(loc, val); return; }
    if (Array.isArray(val)) {
      if (val.length === 2) gl.uniform2f(loc, val[0], val[1]);
      else if (val.length === 3) gl.uniform3f(loc, val[0], val[1], val[2]);
      else if (val.length === 4) gl.uniform4f(loc, val[0], val[1], val[2], val[3]);
    }
  }

  function drawTo(targetFbo, prog, uniforms = {}) {
    gl.useProgram(prog);
    gl.bindFramebuffer(gl.FRAMEBUFFER, targetFbo);
    gl.bindVertexArray(vao);
    for (const [k,v] of Object.entries(uniforms)) setUniform(prog, k, v);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    gl.bindVertexArray(null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  }

  const SIM = {
    dt: 0.016,
    dyeDissipation: 0.985,
    velDissipation: 0.99,
    pressureIters: 18,
    curlStrength: 22.0,
    splatRadius: 0.012,
  };

  function simRes() {
    const base = 240;
    const aspect = canvas.width / canvas.height;
    return { w: Math.max(64, Math.floor(base * aspect)), h: base };
  }
  function dyeRes() {
    const base = 512;
    const aspect = canvas.width / canvas.height;
    return { w: Math.max(128, Math.floor(base * aspect)), h: base };
  }

  let velocity, dye, divergence, pressure, curl;

  function init() {
    const s = simRes();
    const d = dyeRes();

    velocity = DoubleFBO(s.w, s.h, gl.RG16F, gl.RG, gl.HALF_FLOAT, gl.LINEAR);
    dye      = DoubleFBO(d.w, d.h, gl.RGBA16F, gl.RGBA, gl.HALF_FLOAT, gl.LINEAR);

    divergence = { tex: tex(s.w,s.h, gl.R16F, gl.RED, gl.HALF_FLOAT, gl.NEAREST) };
    divergence.fbo = fbo(divergence.tex);

    pressure = DoubleFBO(s.w,s.h, gl.R16F, gl.RED, gl.HALF_FLOAT, gl.NEAREST);

    curl = { tex: tex(s.w,s.h, gl.R16F, gl.RED, gl.HALF_FLOAT, gl.NEAREST) };
    curl.fbo = fbo(curl.tex);

    gl.clearColor(0,0,0,1);
    [velocity.read.fbo, velocity.write.fbo, dye.read.fbo, dye.write.fbo, pressure.read.fbo, pressure.write.fbo, divergence.fbo, curl.fbo]
      .forEach(f => { gl.bindFramebuffer(gl.FRAMEBUFFER, f); gl.clear(gl.COLOR_BUFFER_BIT); });
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  }

  init();
  window.addEventListener('resize', () => { resize(); init(); });

  function hsv2rgb(h,s,v){
    const f=(n)=>{const k=(n+h*6)%6;return v - v*s*Math.max(Math.min(k,4-k,1),0);}
    return [f(5),f(3),f(1)];
  }

  const pointer = { down:false, x:.5, y:.5, px:.5, py:.5, dx:0, dy:0, color:[1,1,1] };

  canvas.addEventListener('pointerdown', (e) => { canvas.setPointerCapture(e.pointerId); pointer.down=true; move(e); });
  canvas.addEventListener('pointermove', (e) => { if(pointer.down) move(e); });
  window.addEventListener('pointerup', () => pointer.down=false);

  function move(e){
    const r = canvas.getBoundingClientRect();
    const x = (e.clientX - r.left) / r.width;
    const y = 1.0 - (e.clientY - r.top) / r.height;
    pointer.px = pointer.x; pointer.py = pointer.y;
    pointer.x = x; pointer.y = y;
    pointer.dx = pointer.x - pointer.px;
    pointer.dy = pointer.y - pointer.py;
  }

  function splat(x,y, dx,dy, rgb){
    // velocity
    bindTex(0, velocity.read.tex);
    drawTo(velocity.write.fbo, P.splat, {
      uTarget: {i:0},
      uPoint: [x,y],
      uRadius: SIM.splatRadius,
      uValue: [dx*120.0, dy*120.0, 0.0]
    });
    velocity.swap();

    // dye
    bindTex(0, dye.read.tex);
    drawTo(dye.write.fbo, P.splat, {
      uTarget: {i:0},
      uPoint: [x,y],
      uRadius: SIM.splatRadius * 1.35,
      uValue: [rgb[0]*2.2, rgb[1]*2.2, rgb[2]*2.2]
    });
    dye.swap();
  }

  function step(){
    const texel = [1/velocity.w, 1/velocity.h];
    const dyeTexel = [1/dye.w, 1/dye.h];

    if(pointer.down){
      const sp = Math.hypot(pointer.dx, pointer.dy);
      if(sp > 1e-6){
        const t = (Date.now()%12000)/12000;
        pointer.color = hsv2rgb(t, 0.9, 1.0);
        splat(pointer.x, pointer.y, pointer.dx, pointer.dy, pointer.color);
      }
    }

    // advect velocity
    bindTex(0, velocity.read.tex);
    bindTex(1, velocity.read.tex);
    drawTo(velocity.write.fbo, P.advect, {
      uVelocity: {i:0},
      uSource: {i:1},
      uTexel: texel,
      uDt: SIM.dt,
      uDissipation: SIM.velDissipation
    });
    velocity.swap();

    // curl
    bindTex(0, velocity.read.tex);
    drawTo(curl.fbo, P.curl, { uVelocity:{i:0}, uTexel: texel });

    // vorticity
    bindTex(0, velocity.read.tex);
    bindTex(1, curl.tex);
    drawTo(velocity.write.fbo, P.vort, {
      uVelocity:{i:0},
      uCurl:{i:1},
      uTexel: texel,
      uDt: SIM.dt,
      uCurlStrength: SIM.curlStrength
    });
    velocity.swap();

    // divergence
    bindTex(0, velocity.read.tex);
    drawTo(divergence.fbo, P.divergence, { uVelocity:{i:0}, uTexel: texel });

    // pressure solve
    // start from 0 each frame (simple & stable)
    gl.clearColor(0,0,0,1);
    gl.bindFramebuffer(gl.FRAMEBUFFER, pressure.read.fbo); gl.clear(gl.COLOR_BUFFER_BIT);
    gl.bindFramebuffer(gl.FRAMEBUFFER, pressure.write.fbo); gl.clear(gl.COLOR_BUFFER_BIT);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    for(let i=0;i<SIM.pressureIters;i++){
      bindTex(0, pressure.read.tex);
      bindTex(1, divergence.tex);
      drawTo(pressure.write.fbo, P.pressure, {
        uPressure:{i:0},
        uDivergence:{i:1},
        uTexel: texel
      });
      pressure.swap();
    }

    // subtract gradient
    bindTex(0, pressure.read.tex);
    bindTex(1, velocity.read.tex);
    drawTo(velocity.write.fbo, P.gradient, {
      uPressure:{i:0},
      uVelocity:{i:1},
      uTexel: texel
    });
    velocity.swap();

    // advect dye
    bindTex(0, velocity.read.tex);
    bindTex(1, dye.read.tex);
    drawTo(dye.write.fbo, P.advect, {
      uVelocity:{i:0},
      uSource:{i:1},
      uTexel: dyeTexel,
      uDt: SIM.dt,
      uDissipation: SIM.dyeDissipation
    });
    dye.swap();

    // display
    bindTex(0, dye.read.tex);
    drawTo(null, P.display, { uTex:{i:0} });
  }

  let last = performance.now();
  function loop(now){
    SIM.dt = Math.min(0.033, (now-last)/1000);
    last = now;
    step();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
