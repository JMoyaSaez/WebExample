<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Koi 3D Volume Background</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #020617;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    #bg {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
    }
  </style>
</head>
<body>
  <div id="bg"></div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.164.0/build/three.module.js";

    // ----- ESCENA -----
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x020617, 0.045);

    const camera = new THREE.PerspectiveCamera(
      45,
      window.innerWidth / window.innerHeight,
      0.1,
      100
    );
    camera.position.set(0, 2.5, 13);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x020617, 1);
    document.getElementById("bg").appendChild(renderer.domElement);

    // ----- LUCES -----
    const hemiLight = new THREE.HemisphereLight(0x7dd3fc, 0x020617, 0.8);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0x93c5fd, 1.0);
    dirLight.position.set(10, 15, 5);
    scene.add(dirLight);

    const pointLight = new THREE.PointLight(0x38bdf8, 1.3, 40);
    pointLight.position.set(0, 8, 0);
    scene.add(pointLight);

    // ----- FONDO / SUELO DEL ESTANQUE -----
    const bottomGeo = new THREE.PlaneGeometry(40, 40, 1, 1);
    const bottomMat = new THREE.MeshPhongMaterial({
      color: 0x020617,
      shininess: 10,
      specular: new THREE.Color(0x0f172a),
    });
    const bottom = new THREE.Mesh(bottomGeo, bottomMat);
    bottom.rotation.x = -Math.PI / 2;
    bottom.position.y = -7;
    scene.add(bottom);

    // ----- PARTÍCULAS (POLVO EN EL AGUA) -----
    const particleCount = 400;
    const particleGeo = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const speeds = new Float32Array(particleCount);

    const BOUNDS = 10;

    for (let i = 0; i < particleCount; i++) {
      positions[i * 3 + 0] = (Math.random() - 0.5) * BOUNDS * 2;
      positions[i * 3 + 1] = -7 + Math.random() * 12;
      positions[i * 3 + 2] = (Math.random() - 0.5) * BOUNDS * 2;
      speeds[i] = 0.4 + Math.random() * 0.6;
    }

    particleGeo.setAttribute("position", new THREE.BufferAttribute(positions, 3));

    const particleMat = new THREE.PointsMaterial({
      color: 0x93c5fd,
      size: 0.06,
      transparent: true,
      opacity: 0.7,
      depthWrite: false,
    });

    const particles = new THREE.Points(particleGeo, particleMat);
    scene.add(particles);

    // ----- CREAR UN PEZ KOI (SIMPLE PERO KOI) -----
    function createKoiMesh(primary, secondary) {
      const group = new THREE.Group();

      // Cuerpo
      const bodyGeo = new THREE.SphereGeometry(0.5, 20, 20);
      const bodyMat = new THREE.MeshPhongMaterial({
        color: primary,
        shininess: 150,
        specular: new THREE.Color(0xffffff),
      });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.scale.set(2.0, 0.9, 0.7);
      group.add(body);

      // Cabeza
      const headGeo = new THREE.SphereGeometry(0.42, 18, 18);
      const headMat = new THREE.MeshPhongMaterial({
        color: secondary,
        shininess: 120,
        specular: new THREE.Color(0xffffff),
      });
      const head = new THREE.Mesh(headGeo, headMat);
      head.position.set(0.9, 0, 0);
      head.scale.set(1, 0.9, 0.9);
      group.add(head);

      // Cola
      const tailGeo = new THREE.ConeGeometry(0.5, 1.2, 18);
      const tailMat = new THREE.MeshPhongMaterial({
        color: primary,
        shininess: 80,
        specular: new THREE.Color(0xffffff),
      });
      const tail = new THREE.Mesh(tailGeo, tailMat);
      tail.rotation.z = Math.PI / 2;
      tail.position.set(-1.4, 0, 0);
      tail.scale.set(1, 0.8, 0.4);
      group.add(tail);

      // Aleta dorsal
      const finGeo = new THREE.PlaneGeometry(0.6, 0.8);
      const finMat = new THREE.MeshPhongMaterial({
        color: primary,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.85,
      });
      const dorsal = new THREE.Mesh(finGeo, finMat);
      dorsal.position.set(0, 0.4, 0);
      dorsal.rotation.x = Math.PI / 2;
      group.add(dorsal);

      // Aletas pectorales
      const pectoralL = new THREE.Mesh(finGeo, finMat.clone());
      pectoralL.scale.set(0.7, 0.7, 0.7);
      pectoralL.position.set(0.3, -0.1, 0.45);
      pectoralL.rotation.y = Math.PI / 3;
      pectoralL.rotation.x = Math.PI / 2.5;
      group.add(pectoralL);

      const pectoralR = pectoralL.clone();
      pectoralR.position.z *= -1;
      group.add(pectoralR); // <- AQUÍ ESTABA EL BUG ANTES

      // Ojos
      const eyeGeo = new THREE.SphereGeometry(0.06, 10, 10);
      const eyeMat = new THREE.MeshBasicMaterial({ color: 0x111827 });
      const eyeL = new THREE.Mesh(eyeGeo, eyeMat);
      eyeL.position.set(1.05, 0.12, 0.14);
      const eyeR = eyeL.clone();
      eyeR.position.z *= -1;
      group.add(eyeL);
      group.add(eyeR);

      // Manchas koi
      const spotGeo = new THREE.SphereGeometry(0.22, 10, 10);
      const spotMat = new THREE.MeshPhongMaterial({
        color: 0x000000,
        transparent: true,
        opacity: 0.22,
      });
      const spot1 = new THREE.Mesh(spotGeo, spotMat);
      spot1.scale.set(1.2, 0.6, 0.8);
      spot1.position.set(0.2, 0.05, 0.25);
      group.add(spot1);

      const spot2 = spot1.clone();
      spot2.position.set(-0.3, -0.03, -0.2);
      group.add(spot2);

      // Que mire hacia +X
      group.rotation.y = Math.PI / 2;

      return { group, tail, dorsal, pectoralL, pectoralR };
    }

    const koiPalette = [
      { primary: 0xf97316, secondary: 0xfef3c7 },
      { primary: 0xfbbf24, secondary: 0xffffff },
      { primary: 0xf97316, secondary: 0xffffff },
      { primary: 0xffedd5, secondary: 0xf97316 },
      { primary: 0xffffff, secondary: 0xf97316 },
    ];

    // ----- CARDUMEN -----
    const koiList = [];
    const KOI_COUNT = 16;

    for (let i = 0; i < KOI_COUNT; i++) {
      const palette = koiPalette[Math.floor(Math.random() * koiPalette.length)];
      const koiParts = createKoiMesh(palette.primary, palette.secondary);
      const mesh = koiParts.group;

      const startPos = new THREE.Vector3(
        (Math.random() - 0.5) * BOUNDS * 1.5,
        -4 + Math.random() * 6,
        (Math.random() - 0.5) * BOUNDS * 1.5
      );
      mesh.position.copy(startPos);

      const dir = new THREE.Vector3(
        (Math.random() - 0.5),
        (Math.random() - 0.2),
        (Math.random() - 0.5)
      ).normalize();
      const speed = 1.5 + Math.random();
      const velocity = dir.multiplyScalar(speed);

      const s = 0.7 + Math.random() * 0.8;
      mesh.scale.set(s, s, s);

      scene.add(mesh);

      koiList.push({
        mesh,
        velocity,
        speed,
        tail: koiParts.tail,
        dorsal: koiParts.dorsal,
        pectoralL: koiParts.pectoralL,
        pectoralR: koiParts.pector
alR,
        wigglePhase: Math.random() * Math.PI * 2,
      });
    }

    // ----- ANIMACIÓN -----
    const clock = new THREE.Clock();

    function animate() {
      const delta = clock.getDelta();
      const t = clock.getElapsedTime();

      // Partículas subiendo
      const posAttr = particles.geometry.attributes.position;
      for (let i = 0; i < particleCount; i++) {
        let y = posAttr.getY(i);
        y += speeds[i] * delta;
        if (y > 5) {
          y = -7 + Math.random() * 2;
          posAttr.setX(i, (Math.random() - 0.5) * BOUNDS * 2);
          posAttr.setZ(i, (Math.random() - 0.5) * BOUNDS * 2);
        }
        posAttr.setY(i, y);
      }
      posAttr.needsUpdate = true;

      // Peces en volumen 3D
      koiList.forEach((k) => {
        const noise = new THREE.Vector3(
          (Math.random() - 0.5) * 0.25 * delta,
          (Math.random() - 0.5) * 0.15 * delta,
          (Math.random() - 0.5) * 0.25 * delta
        );
        k.velocity.add(noise);
        k.velocity.normalize().multiplyScalar(k.speed);

        k.mesh.position.addScaledVector(k.velocity, delta);

        const p = k.mesh.position;
        const limitX = BOUNDS;
        const limitYTop = 4;
        const limitYBottom = -7;
        const limitZ = BOUNDS;

        if (p.x > limitX || p.x < -limitX) {
          k.velocity.x *= -1;
        }
        if (p.z > limitZ || p.z < -limitZ) {
          k.velocity.z *= -1;
        }
        if (p.y > limitYTop || p.y < limitYBottom) {
          k.velocity.y *= -1;
        }

        const dir = k.velocity.clone().normalize();
        const targetPos = p.clone().add(dir);
        k.mesh.lookAt(targetPos);
        k.mesh.rotation.y += Math.PI / 2;

        const wiggle = Math.sin(t * 10 + k.wigglePhase) * 0.5;
        if (k.tail) k.tail.rotation.y = wiggle;

        const flap = Math.sin(t * 6 + k.wigglePhase) * 0.25;
        if (k.dorsal) k.dorsal.rotation.z = Math.sin(t * 4 + k.wigglePhase) * 0.15;
        if (k.pectoralL && k.pectoralR) {
          k.pectoralL.rotation.y = Math.PI / 3 + flap;
          k.pectoralR.rotation.y = -Math.PI / 3 - flap;
        }
      });

      pointLight.position.x = Math.sin(t * 0.4) * 6;
      pointLight.position.z = Math.cos(t * 0.35) * 6;
      pointLight.position.y = 6 + Math.sin(t * 0.6) * 1.5;

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    animate();

    // ----- RESIZE -----
    window.addEventListener("resize", () => {
      const w = window.innerWidth;
      const h = window.innerHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    });
  </script>
</body>
</html>
