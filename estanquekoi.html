<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Koi 3D Background</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #020617;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    /* El canvas WebGL ocupará toda la pantalla */
    #bg {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
    }
  </style>
</head>
<body>
  <!-- Three.js insertará aquí el canvas -->
  <div id="bg"></div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.164.0/build/three.module.js";

    // ----- ESCENA BÁSICA -----
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x020617, 0.035);

    const camera = new THREE.PerspectiveCamera(
      45,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 15, 28);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x020617, 1);
    document.getElementById("bg").appendChild(renderer.domElement);

    // ----- LUCES -----
    const ambLight = new THREE.AmbientLight(0x91c4ff, 0.9);
    scene.add(ambLight);

    const dirLight = new THREE.DirectionalLight(0x7dd3fc, 0.8);
    dirLight.position.set(20, 40, 10);
    scene.add(dirLight);

    const pointLight = new THREE.PointLight(0x38bdf8, 1.3, 80);
    pointLight.position.set(0, 12, 0);
    scene.add(pointLight);

    // ----- "AGUA" (PLANO) -----
    const waterGeo = new THREE.PlaneGeometry(80, 80, 64, 64);
    const waterMat = new THREE.MeshPhongMaterial({
      color: 0x02081b,
      shininess: 80,
      specular: new THREE.Color(0x3b82f6),
      transparent: true,
      opacity: 0.95,
      side: THREE.DoubleSide,
    });
    const water = new THREE.Mesh(waterGeo, waterMat);
    water.rotation.x = -Math.PI / 2;
    scene.add(water);

    // Pequeña deformación tipo ola
    const waterVertices = water.geometry.attributes.position;
    const waveOffsets = new Float32Array(waterVertices.count);
    for (let i = 0; i < waterVertices.count; i++) {
      waveOffsets[i] = Math.random() * Math.PI * 2;
    }

    // ----- GEOMETRÍA BASE DE LOS PECES (CUERPO + COLA) -----
    const bodyGeo = new THREE.CapsuleGeometry(0.4, 1.6, 8, 16);
    const tailGeo = new THREE.ConeGeometry(0.4, 0.9, 16);

    // Paleta de colores "koi"
    const colors = [0xf97316, 0xfbbf24, 0xfef3c7, 0xffedd5, 0xfee2e2];

    function createKoi() {
      const group = new THREE.Group();

      const color = colors[Math.floor(Math.random() * colors.length)];
      const bodyMat = new THREE.MeshPhongMaterial({
        color,
        shininess: 120,
        specular: new THREE.Color(0xffffff),
      });
      const tailMat = new THREE.MeshPhongMaterial({
        color,
        shininess: 80,
        specular: new THREE.Color(0xffffff),
      });

      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.castShadow = true;
      body.receiveShadow = false;

      const tail = new THREE.Mesh(tailGeo, tailMat);
      tail.position.set(-1.1, 0, 0);
      tail.rotation.z = Math.PI; // apuntar hacia atrás

      group.add(body);
      group.add(tail);

      // Ojos sencillos
      const eyeGeo = new THREE.SphereGeometry(0.07, 8, 8);
      const eyeMat = new THREE.MeshBasicMaterial({ color: 0x111827 });

      const eyeL = new THREE.Mesh(eyeGeo, eyeMat);
      eyeL.position.set(0.55, 0.18, 0.18);
      const eyeR = eyeL.clone();
      eyeR.position.z *= -1;

      group.add(eyeL);
      group.add(eyeR);

      // Escala aleatoria
      const s = 0.8 + Math.random() * 0.7;
      group.scale.set(s, s, s);

      scene.add(group);

      return {
        mesh: group,
        angle: Math.random() * Math.PI * 2,
        radius: 6 + Math.random() * 12,
        heightBase: 0.2 + Math.random() * 0.8,
        heightAmp: 0.5 + Math.random() * 0.8,
        speed: 0.2 + Math.random() * 0.5,
        swayAmp: 0.2 + Math.random() * 0.4,
        swayFreq: 1.5 + Math.random() * 1.5,
        tailPhase: Math.random() * Math.PI * 2,
      };
    }

    const KOI_COUNT = 18;
    const koiList = [];
    for (let i = 0; i < KOI_COUNT; i++) {
      koiList.push(createKoi());
    }

    // ----- PARTÍCULAS (BURBUJAS / POLVO EN EL AGUA) -----
    const particleCount = 350;
    const particleGeo = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const speeds = new Float32Array(particleCount);

    for (let i = 0; i < particleCount; i++) {
      positions[i * 3 + 0] = (Math.random() - 0.5) * 40;
      positions[i * 3 + 1] = Math.random() * 10;
      positions[i * 3 + 2] = (Math.random() - 0.5) * 40;
      speeds[i] = 0.005 + Math.random() * 0.02;
    }

    particleGeo.setAttribute("position", new THREE.BufferAttribute(positions, 3));

    const particleMat = new THREE.PointsMaterial({
      color: 0x93c5fd,
      size: 0.08,
      transparent: true,
      opacity: 0.6,
      depthWrite: false,
    });

    const particles = new THREE.Points(particleGeo, particleMat);
    scene.add(particles);

    // ----- ANIMACIÓN -----
    const clock = new THREE.Clock();

    function animate() {
      const t = clock.getElapsedTime();

      // Deformar agua
      for (let i = 0; i < waterVertices.count; i++) {
        const x = waterVertices.getX(i);
        const z = waterVertices.getZ(i);
        const wave =
          Math.sin(x * 0.25 + t * 1.2 + waveOffsets[i]) * 0.12 +
          Math.cos(z * 0.3 + t * 0.8 + waveOffsets[i]) * 0.09;
        waterVertices.setY(i, wave);
      }
      waterVertices.needsUpdate = true;
      water.geometry.computeVertexNormals();

      // Peces
      koiList.forEach((k) => {
        k.angle += k.speed * 0.02;

        const x = Math.cos(k.angle) * k.radius;
        const z = Math.sin(k.angle) * k.radius;
        const y = k.heightBase + Math.sin(t * 0.8 + k.angle) * k.heightAmp;

        k.mesh.position.set(x, y, z);

        // Miran en dirección de avance
        k.mesh.rotation.y = -k.angle + Math.PI / 2;

        // Cabeceo suave
        k.mesh.rotation.x = Math.sin(t * k.swayFreq + k.angle) * k.swayAmp;

        // “Aleteo” de cola
        const tail = k.mesh.children[1]; // body=0, tail=1
        tail.rotation.y = Math.sin(t * 8 + k.tailPhase) * 0.6;
      });

      // Partículas subiendo
      const pos = particles.geometry.attributes.position;
      for (let i = 0; i < particleCount; i++) {
        let y = pos.getY(i);
        y += speeds[i];
        if (y > 10) {
          y = 0;
          pos.setX(i, (Math.random() - 0.5) * 40);
          pos.setZ(i, (Math.random() - 0.5) * 40);
        }
        pos.setY(i, y);
      }
      pos.needsUpdate = true;

      // Luz que se mueve (efecto caústica suave)
      pointLight.position.x = Math.sin(t * 0.5) * 10;
      pointLight.position.z = Math.cos(t * 0.4) * 10;
      pointLight.position.y = 12 + Math.sin(t * 0.7) * 2;

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    animate();

    // ----- RESIZE -----
    window.addEventListener("resize", () => {
      const w = window.innerWidth;
      const h = window.innerHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    });
  </script>
</body>
</html>
