<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Koi Pond Background</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html,
    body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      /* Quitamos el fondo opaco del body */
      background: transparent;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
    }

    /* Canvas ocupando toda la pantalla, como background */
    #koi-pond {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      /* z-index: -1;  <-- esto hacÃ­a que no se viera */
      z-index: 0;
    }
  </style>
</head>
<body>
  <canvas id="koi-pond"></canvas>

  <script>
    const canvas = document.getElementById("koi-pond");
    const ctx = canvas.getContext("2d");

    let width = window.innerWidth;
    let height = window.innerHeight;
    let dpr = window.devicePixelRatio || 1;

    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      dpr = window.devicePixelRatio || 1;

      canvas.width = width * dpr;
      canvas.height = height * dpr;
      canvas.style.width = width + "px";
      canvas.style.height = height + "px";

      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    window.addEventListener("resize", resize);
    resize();

    const bubbles = [];
    const BUBBLE_COUNT = 40;

    function createBubble() {
      return {
        x: Math.random() * width,
        y: height + Math.random() * height,
        radius: 3 + Math.random() * 8,
        speed: 0.2 + Math.random() * 0.6,
        alpha: 0.1 + Math.random() * 0.25,
      };
    }

    for (let i = 0; i < BUBBLE_COUNT; i++) {
      bubbles.push(createBubble());
    }

    const koiColors = [
      "#fef3c7",
      "#fed7aa",
      "#f97316",
      "#fbbf24",
      "#e5e7eb",
    ];

    class Koi {
      constructor() {
        const direction = Math.random() < 0.5 ? 1 : -1;

        this.length = 60 + Math.random() * 80;
        this.width = this.length * (0.28 + Math.random() * 0.12);
        this.baseY = Math.random() * height;
        this.x =
          direction === 1 ? -this.length - Math.random() * width : width + this.length + Math.random() * width;
        this.y = this.baseY;
        this.speed = (0.3 + Math.random() * 0.5) * direction;
        this.waveAmp = 18 + Math.random() * 24;
        this.waveFreq = 0.0012 + Math.random() * 0.0018;
        this.phase = Math.random() * Math.PI * 2;
        this.color = koiColors[Math.floor(Math.random() * koiColors.length)];
        this.spotsColor = "rgba(0,0,0,0.18)";
        this.flip = direction === -1;
      }

      update(time) {
        this.x += this.speed;
        this.y =
          this.baseY +
          Math.sin(this.x * this.waveFreq + this.phase + time * 0.0004) * this.waveAmp;

        if (this.speed > 0 && this.x - this.length > width + 100) {
          this.reset(-1);
        } else if (this.speed < 0 && this.x + this.length < -100) {
          this.reset(1);
        }
      }

      reset(direction) {
        this.length = 60 + Math.random() * 80;
        this.width = this.length * (0.28 + Math.random() * 0.12);
        this.baseY = Math.random() * height;
        this.y = this.baseY;
        this.speed = (0.3 + Math.random() * 0.5) * direction;
        this.waveAmp = 18 + Math.random() * 24;
        this.waveFreq = 0.0012 + Math.random() * 0.0018;
        this.phase = Math.random() * Math.PI * 2;
        this.color = koiColors[Math.floor(Math.random() * koiColors.length)];
        this.flip = direction === -1;
        this.x =
          direction === 1
            ? -this.length - Math.random() * width
            : width + this.length + Math.random() * width;
      }

      draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        if (this.flip) ctx.scale(-1, 1);

        const bodyLength = this.length;
        const bodyWidth = this.width;

        ctx.globalAlpha = 0.4;
        ctx.fillStyle = "rgba(0,0,0,0.4)";
        ctx.beginPath();
        ctx.ellipse(
          0,
          bodyWidth * 0.15,
          bodyLength * 0.55,
          bodyWidth * 0.7,
          0,
          0,
          Math.PI * 2
        );
        ctx.fill();

        ctx.globalAlpha = 1;

        const grad = ctx.createLinearGradient(
          -bodyLength / 2,
          0,
          bodyLength / 2,
          0
        );
        grad.addColorStop(0, this.color);
        grad.addColorStop(0.5, "#ffffff");
        grad.addColorStop(1, this.color);

        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.ellipse(
          0,
          0,
          bodyLength / 2,
          bodyWidth / 2,
          0,
          0,
          Math.PI * 2
        );
        ctx.fill();

        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.moveTo(-bodyLength / 2, 0);
        ctx.quadraticCurveTo(
          -bodyLength * 0.75,
          -bodyWidth * 0.8,
          -bodyLength,
          0
        );
        ctx.quadraticCurveTo(
          -bodyLength * 0.75,
          bodyWidth * 0.8,
          -bodyLength / 2,
          0
        );
        ctx.fill();

        ctx.globalAlpha = 0.75;
        ctx.beginPath();
        ctx.moveTo(-bodyLength * 0.1, -bodyWidth * 0.1);
        ctx.quadraticCurveTo(
          bodyLength * 0.05,
          -bodyWidth * 0.9,
          bodyLength * 0.3,
          -bodyWidth * 0.2
        );
        ctx.quadraticCurveTo(
          bodyLength * 0.05,
          -bodyWidth * 0.4,
          -bodyLength * 0.1,
          -bodyWidth * 0.1
        );
        ctx.fillStyle = "rgba(255,255,255,0.8)";
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(-bodyLength * 0.1, bodyWidth * 0.1);
        ctx.quadraticCurveTo(
          bodyLength * 0.05,
          bodyWidth * 0.9,
          bodyLength * 0.3,
          bodyWidth * 0.2
        );
        ctx.quadraticCurveTo(
          bodyLength * 0.05,
          bodyWidth * 0.4,
          -bodyLength * 0.1,
          bodyWidth * 0.1
        );
        ctx.fill();
        ctx.globalAlpha = 1;

        ctx.fillStyle = this.spotsColor;
        ctx.beginPath();
        ctx.ellipse(
          bodyLength * 0.1,
          -bodyWidth * 0.15,
          bodyLength * 0.18,
          bodyWidth * 0.3,
          0.3,
          0,
          Math.PI * 2
        );
        ctx.fill();

        ctx.beginPath();
        ctx.ellipse(
          -bodyLength * 0.1,
          bodyWidth * 0.05,
          bodyLength * 0.16,
          bodyWidth * 0.25,
          -0.4,
          0,
          Math.PI * 2
        );
        ctx.fill();

        ctx.fillStyle = "#ffffff";
        ctx.beginPath();
        ctx.ellipse(
          bodyLength * 0.3,
          0,
          bodyLength * 0.18,
          bodyWidth * 0.35,
          0,
          0,
          Math.PI * 2
        );
        ctx.fill();

        ctx.fillStyle = "#111827";
        ctx.beginPath();
        ctx.arc(bodyLength * 0.38, -bodyWidth * 0.08, bodyWidth * 0.08, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }
    }

    const koiCount = 12;
    const koiList = [];
    for (let i = 0; i < koiCount; i++) {
      koiList.push(new Koi());
    }

    let lastTime = 0;

    function drawBackground(time) {
      const grad = ctx.createLinearGradient(0, 0, 0, height);
      grad.addColorStop(0, "#020617");
      grad.addColorStop(0.4, "#02061d");
      grad.addColorStop(1, "#030712");
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, width, height);

      ctx.save();
      ctx.globalAlpha = 0.1;
      for (let i = 0; i < 3; i++) {
        const gx = (Math.sin(time * 0.0002 + i) + 1) * 0.5 * width;
        const gy = (Math.cos(time * 0.00025 + i * 2) + 1) * 0.5 * height;
        const r = width * 0.7;

        const g = ctx.createRadialGradient(gx, gy, 0, gx, gy, r);
        g.addColorStop(0, "rgba(59,130,246,0.6)");
        g.addColorStop(0.4, "rgba(56,189,248,0.35)");
        g.addColorStop(1, "transparent");

        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(gx, gy, r, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }

    function updateBubbles() {
      for (const b of bubbles) {
        b.y -= b.speed;
        if (b.y + b.radius < -20) {
          const idx = bubbles.indexOf(b);
          bubbles[idx] = createBubble();
        }
      }
    }

    function drawBubbles() {
      ctx.save();
      for (const b of bubbles) {
        ctx.globalAlpha = b.alpha;
        const g = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, b.radius);
        g.addColorStop(0, "rgba(191,219,254,0.9)");
        g.addColorStop(0.4, "rgba(191,219,254,0.4)");
        g.addColorStop(1, "transparent");
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }

    function loop(time) {
      const delta = time - lastTime;
      lastTime = time;

      drawBackground(time);
      updateBubbles();
      drawBubbles();

      for (const koi of koiList) {
        koi.update(time);
        koi.draw(ctx);
      }

      requestAnimationFrame(loop);
    }

    requestAnimationFrame(loop);
  </script>
</body>
</html>
